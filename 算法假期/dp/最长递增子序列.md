## 基本问题 找到最长递增子序列和最长不下降子序列 nlogn做法
最长递增子序列
ends数组 ends i 含义是长度为i+1的最长递增子序列的最小结尾，有个len记录当前ends更新到的长度。
dp数组可有可无，意思是dp i 是以i位置结尾的最长递增子序列长度
主要方法就是从头到尾遍历原数组，每到一个元素查找ends数组中>=当前元素的最左位置（二分），如果找到这个元素，把ends数组中的值更新为当前元素。dp[i]就是这个位置对应多长的子序列。如果找不到>=的，这个元素填在ends的末尾，len++
最终只要求长度的话其实len就行了，dp其实没有用。

二分查找>=当前元素的最左位置
int l=0,r=len-1;
int ans=-1;
while(l<=r)
{
    int m=(l+r)/2;
    if(ends[m]>=target)  //看看
    {
        ans=m;
        r=m-1;
    }else
    {
        l=m+1;
    }
}
return ans;

最长不下降子序列就是修改二分策略，在ends数组中找严格>当前元素的最左位置

### 拓展题目1
// 使数组K递增的最少操作次数
// 给你一个下标从0开始包含n个正整数的数组arr，和一个正整数k
// 如果对于每个满足 k <= i <= n-1 的下标 i
// 都有 arr[i-k] <= arr[i] ，那么称 arr 是K递增的
// 每一次操作中，你可以选择一个下标i并将arr[i]改成任意正整数
// 请你返回对于给定的 k ，使数组变成K递增的最少操作次数
// 测试链接 : https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
这种题目本质就是对数组按照模k同余来进行分类，大致分成k组，然后在每一组中求最长不下降子序列就行

### 拓展题目二
// 俄罗斯套娃信封问题
// 给你一个二维整数数组envelopes ，其中envelopes[i]=[wi, hi]
// 表示第 i 个信封的宽度和高度
// 当另一个信封的宽度和高度都比这个信封大的时候
// 这个信封就可以放进另一个信封里，如同俄罗斯套娃一样
// 请计算 最多能有多少个信封能组成一组“俄罗斯套娃”信封
// 即可以把一个信封放到另一个信封里面，注意不允许旋转信封
// 测试链接 : https://leetcode.cn/problems/russian-doll-envelopes/
这题做法比较巧妙，先把所有信封按照宽度从小到大排序。如果宽度一样，按照高度从大到小排。然后对于排列好的高度数组，求最长递增子序列就行了。
排序策略的原因，宽度排序是为了降维，高度排序是因为题目中说只有严格大于才能套信封，高度从大到小排序使得相同宽度的无法套娃。

还有就是这种嵌套或者构造问题，本身给的东西都是无序的，都是得先排序再求最大递增子序列，看限制条件


### 拓展题目三
// 最长数对链
// 给你一个由n个数对组成的数对数组pairs
// 其中 pairs[i] = [lefti, righti] 且 lefti < righti
// 现在，我们定义一种 跟随 关系，当且仅当 b < c 时
// 数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面
// 我们用这种形式来构造 数对链
// 找出并返回能够形成的最长数对链的长度
// 测试链接 : https://leetcode.cn/problems/maximum-length-of-pair-chain/
这题首先肯定得排序，就按照left从小到大排序就行
然后ends数组里面放的是长度为i+1的最长数对链，最小的right结尾
但是当我们更新查找时，二分下，用当前left找>=的最左位置。
然后想要更新ends时，用当前元素的right和你二分搜到的那个数比较，考虑是否更新

也就是说，ends存的是最小right，二分时拿left进去搜，搜到了，用right看看用不用更新