## 区间dp
一般dp数组定义在一个区间范围（l，r），然后一个dp值总是依赖于区间长度更小的dp值
### 展开手段（重要！！）
1.讨论区间两端的端点进行展开
2.讨论中间划分点进行展开

dp写代码就是两层for循环，外面一层从小到大列举区间长度（区间长度小的就是basecase），内层for循环就是列举区间开始点，然后推出区间结束点，这样展开就行了

### 例题1
// 让字符串成为回文串的最少插入次数
// 给你一个字符串 s
// 每一次操作你都可以在字符串的任意位置插入任意字符
// 请你返回让s成为回文串的最少操作次数
// 测试链接 : https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/

basecase是串大小为1或2
展开手段是讨论两端字符是否相等，如果相等就依赖l+1,r-1的区间
如果不相等，就依赖 l,r-1  or  l+1,r就是讨论一下往哪一侧来添加一个字符分情况


### 例题2
// 预测赢家
// 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏
// 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手
// 开始时，两个玩家的初始分值都是 0
// 每一回合，玩家从数组的任意一端取一个数字
// 取到的数字将会从数组中移除，数组长度减1
// 玩家选中的数字将会加到他的得分上
// 当数组中没有剩余数字可取时游戏结束
// 如果玩家 1 能成为赢家，返回 true
// 如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true
// 你可以假设每个玩家的玩法都会使他的分数最大化
// 测试链接 : https://leetcode.cn/problems/predict-the-winner/

这题由于所有的策略是围绕某个区间两侧的，所以我们可以想到区间dp的思路
dp数组定义为 在数组 l 到 r的区间上，先后手玩家都足够聪明下，先手玩家能获得的最大分数

展开分两个情况
1.先手玩家拿左端点
2..先手玩家拿右端点。
在情况1中后手玩家，由于也足够聪明，在留给玩家1的，l+2 r  ，l + 1  r-1这两种残局中，总会给玩家1最差的残局  nums[l] + Math.min(dp[l + 2][r], dp[l + 1][r - 1]) 
情况二同理

### 例题三
// 多边形三角剖分的最低得分
// 你有一个凸的 n 边形，其每个顶点都有一个整数值
// 给定一个整数数组values，其中values[i]是第i个顶点的值(顺时针顺序)
// 假设将多边形 剖分 为 n - 2 个三角形
// 对于每个三角形，该三角形的值是顶点标记的乘积
// 三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和
// 返回 多边形进行三角剖分后可以得到的最低分
// 测试链接 : https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/

这道题不是很好想象，他的本质是  values 0  values n-1之间总会有一条边然后选取中间点构成一个三角形，中间点可以选择中间任意一个点，然后可以直接划分成左右两部分求解，由于不可交叉，所有左右两部分也不会交织构成三角形。

之后我们给他转化成任意子问题，然后区间dp求解
dp[l][r] = Math.min(dp[l][r], dp[l][m] + dp[m][r] + arr[l] * arr[m] * arr[r]);  //更新步骤


### 例题四
// 切棍子的最小成本
// 有一根长度为n个单位的木棍，棍上从0到n标记了若干位置
// 给你一个整数数组cuts，其中cuts[i]表示你需要将棍子切开的位置
// 你可以按顺序完成切割，也可以根据需要更改切割的顺序
// 每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和
// 对棍子进行切割将会把一根木棍分成两根较小的木棍
// 这两根木棍的长度和就是切割前木棍的长度
// 返回切棍子的最小总成本
// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/

dp数组含义  切点[l....r]，决定一个顺序 ，让切点都切完，总代价最小
原cuts数组处理一下，先排序，接着  左侧填一个 0 位置，右侧填一个 n位置，这个修改主要是为了处理边界情况更方便，就是可以用 l-1 r+1 位置的值相减 直接得到代价

总问题就是 cut 数组扩充后是 0 cut1 cut2 ……cutm,n,   共 m+2个数, 最后求下标  1到m的dp值
讨论中间第一次切 cut k  ，付出代价用 l-1 r+1 位置的值相减，然后依赖子问题为  l到k-1 以及 k+1 到r这两个子问题

### 例题5
// 戳气球
// 有 n 个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中
// 现在要求你戳破所有的气球。戳破第 i 个气球
// 你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币
// 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号
// 如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球
// 求所能获得硬币的最大数量
// 测试链接 : https://leetcode.cn/problems/burst-balloons/

这个题过于巧妙了
首先dp数组的含义为 arr[l...r]这些气球决定一个顺序，获得最大得分
然后重点是进入dp数组有前提就是 l-1 位置 r+1位置都不能被打爆，
与之配合的是尝试策略是，选取一个中间点作为最后一个被打爆的气球，这样依赖子问题的时候依然可以保证  l-1 位置 r+1位置都不能被打爆这个前提条件

为了使得这个逻辑走通，我们需要在数组的最前端和最后端都补充一个 价值为1的气球不被打爆

### 例题6
// 布尔运算
// 给定一个布尔表达式和一个期望的布尔结果 result
// 布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成
// 布尔表达式一定是正确的，不需要检查有效性
// 但是其中没有任何括号来表示优先级
// 你可以随意添加括号来改变逻辑优先级
// 目的是让表达式能够最终得出result的结果
// 返回最终得出result有多少种不同的逻辑计算顺序
// 测试链接 : https://leetcode.cn/problems/boolean-evaluation-lcci/

这个和矩阵链乘法很像，就是穷举 在 dp 某个区间 l 到 r上  经过打括号之后的最后一次运算在哪个位置。这道题还要注意，要讨论那个最后一次运算符是不同逻辑运算，讨论两侧子问题情况不同。
然后准备两个dp表，一个是 区间 l r得到True的方案数 ，区间 l r得到Falsee的方案数 就行了
