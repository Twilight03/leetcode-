## 完全背包
就是那种每种物品可以取无限次的背包
我们知道可以用贪心来做，但是这里我们尝试动态规划
这里动态规划的转移方程和01背包很像
  	dp[i][j] = Math.max(dp[i - 1][j];, dp[i][j - cost[i]] + val[i]);
  	这里不一样就是在看的是dp[i][j-cost[i]]  也就是利用本行更新的结果
  	而01背包利用上一行更新的结果，dp[i-1][j-cost[i]]
public static long compute1() {
    // dp[0][.....] = 0
    int[][] dp = new int[m + 1][t + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 0; j <= t; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j - cost[i] >= 0) {
                dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + val[i]);
            }
        }
    }
    return dp[m][t];
    
## 分组背包及拓展问题的转化
// 分组背包(模版)
// 给定一个正数m表示背包的容量，有n个货物可供挑选
// 每个货物有自己的体积(容量消耗)、价值(获得收益)、组号(分组)
// 同一个组的物品只能挑选1件，所有挑选物品的体积总和不能超过背包容量
// 怎么挑选货物能达到价值最大，返回最大的价值
// 测试链接 : https://www.luogu.com.cn/problem/P1757

// 从栈中取出K个硬币的最大面值和
// 一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币
// 每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里
// 给你一个列表 piles ，其中 piles[i] 是一个整数数组
// 分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k
// 请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少
// 测试链接 : https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/

分组背包就是把关联限制关系的所有物品看成一个物品，最外层是一个01背包，选这种综合物品要或者不要。然后复杂的就是每一个综合物品如果要了，他的展开方式比较多。

比如第一个题要求一组只能要一个，你就讨论要哪一个
第二个题目，一组中要求必须按前缀的顺序取物品，你就统计前缀jiuxing
第二个题目这种，其实和取得顺序没有关系，只和各个堆取了多少有关系的题目很多，要看清本质


## 多重背包
就是每个物品不仅有重量 价值  还有限制每个物品最多拿多少个
这个问题的朴素方法其实就是 dp i j= max(   dp i-1 j  ,    dp i-1 j-cost  ,     dp i-1 j- 2*cost……)
这样依次枚举即可
有一个优化枚举的方法就是二进制拆解
比如有一个物品限制拿21个  21 =1+2+4+8+6
然后你创造 5个物品，  重量和价值分别为  1*weight,2*weight,4*weight,8*weight,6*weight
1*cost,2*cost,4*cost,8*cost,6*cost
相当于把这个物品拆成这五个物品。
把所有的物品都这样拆解，最后就是一个01背包的问题


还有一个单调队列优化的版本，更快