## 经典01背包
dp数组是二维，  dp  i  j 的含义是在考虑前i个物品的前提下，背包的容量不超过j最多可以获得多大的价值，
整体转移方程  讨论要不要取第i件物品，取的前提是j大于当前物品的重量
取得话  dp i j =val[i] + dp(i-1 )( j-cost[i])    不取的话dp(i)(j)=dp(i-1)(j)
二者取最大值即可。注意取的前提是  j > cost[i]  就行
整理答案外层循环是i，每个更新依赖于 i-1行。内层循环从重量从小到大即可


### 拓展题目1
// 夏季特惠
// 某公司游戏平台的夏季特惠开始了，你决定入手一些游戏
// 现在你一共有X元的预算，平台上所有的 n 个游戏均有折扣
// 标号为 i 的游戏的原价a_i元，现价只要b_i元
// 也就是说该游戏可以优惠 a_i - b_i，并且你购买该游戏能获得快乐值为w_i
// 由于优惠的存在，你可能做出一些冲动消费导致最终买游戏的总费用超过预算
// 只要满足 : 获得的总优惠金额不低于超过预算的总金额
// 那在心理上就不会觉得吃亏。
// 现在你希望在心理上不觉得吃亏的前提下，获得尽可能多的快乐值。
// 测试链接 : https://leetcode.cn/problems/tJau2o/

分析一下，这道题的限制是用现价买游戏会消耗预算，折扣的优惠会增加预算
所以我们考虑转化，就是用 现价的消耗 减去 优惠  才是净消耗
净消耗为负数的代表买这些游戏稳赚不亏，这些必须买
净消耗为正数，才是传统背包的消耗
我们先把净消耗为负数全买了，获得一个新的最大容量
然后用这个容量在净消耗为正数上做01背包问题即可


### 拓展题目二
// 目标和
// 给你一个非负整数数组 nums 和一个整数 target 。
// 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数
// 可以构造一个表达式
// 例如nums=[2, 1]，可以在2之前添加'+' ，在1之前添加'-'
// 然后串联起来得到表达式 "+2-1" 。
// 返回可以通过上述方法构造的，运算结果等于 target 的不同表达式的数目
// 测试链接 : https://leetcode.cn/problems/target-sum/

先说暴力搜索和记忆化搜索的办法，最后说一下如何转化成背包
#### 暴力搜索
// nums[0...i-1]范围上，已经形成的累加和是sum
// nums[i...]范围上，每个数字可以标记+或者-
// 最终形成累加和为target的不同表达式数目
public static int f1(int[] nums, int target, int i, int sum) {
    if (i == nums.length) {
        return sum == target ? 1 : 0;
    }
    return f1(nums, target, i + 1, sum + nums[i]) + f1(nums, target, i + 1, sum - nums[i]);
}
#### 记忆化搜索
正常需要一个 二维dp 数组来做  前i个数组成了sum的和  这两个维度
但是sum有负数，我们用一个二层哈希表即可
// 普通尝试，记忆化搜索版
public static int findTargetSumWays2(int[] nums, int target) {
    // i, sum -> value（返回值 ）
    HashMap<Integer, HashMap<Integer, Integer>> dp = new HashMap<>();
    return f2(nums, target, 0, 0, dp);
}

// 因为累加和可以为负数
// 所以缓存动态规划表用哈希表
public static int f2(int[] nums, int target, int i, int j, HashMap<Integer, HashMap<Integer, Integer>> dp) {
    if (i == nums.length) {
        return j == target ? 1 : 0;
    }
    if (dp.containsKey(i) && dp.get(i).containsKey(j)) {
        return dp.get(i).get(j);
    }
    int ans = f2(nums, target, i + 1, j + nums[i], dp) + f2(nums, target, i + 1, j - nums[i], dp);
    dp.putIfAbsent(i, new HashMap<>());
    dp.get(i).put(j, ans);
    return ans;
}
#### 转化成背包问题   -----基于数学等式的分析
A是取正数的集合，B是取负数的集合
所以任何一种方案，都一定有 sum(A) - sum(B) = target
// 现在我们来处理一下这个等式，把左右两边都加上sum(A) + sum(B)，那么就会变成如下：
// sum(A) - sum(B) + sum(A) + sum(B) = target + sum(A) + sum(B)
// 2 * sum(A) = target + 数组所有数的累加和
// sum(A) = (target + 数组所有数的累加和) / 2


问题转化成了这个数组中有多少子序列，和为(target + 数组所有数的累加和) / 2
// 01背包问题(子集累加和严格是t) 
dp i j 含义是前i个数有多少子序列和为j(严格为j)
这里不是标准的背包，但是01背包的基本思想就是划分要不要当前的元素
并且特点是依赖于二维dp第二维度是重量weight
	// dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]
	

### 拓展题目3
// 最后一块石头的重量 II
// 有一堆石头，用整数数组 stones 表示
// 其中 stones[i] 表示第 i 块石头的重量。
// 每一回合，从中选出任意两块石头，然后将它们一起粉碎
// 假设石头的重量分别为 x 和 y，且 x <= y
// 那么粉碎的可能结果如下：
// 如果 x == y，那么两块石头都会被完全粉碎；
// 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x
// 最后，最多只会剩下一块 石头，返回此石头 最小的可能重量
// 如果没有石头剩下，就返回 0
// 测试链接 : https://leetcode.cn/problems/last-stone-weight-ii/

这题和上面一样，最后转化成 把所有石头分成两个集合，最后剩下的重量就是这两个集合重量之差。所以我们需要让一个集合的重量<=一半总重量并且尽量接近即可
// 非负数组nums中，子序列累加和不超过t，但是最接近t的累加和是多少
// 01背包问题(子集累加和尽量接近t)
dp数组是  考虑前i个数，找一个子序列和不超过j且尽量接近，最大能是多少


## 有依赖背包
// 有依赖的背包(模版)
// 物品分为两大类：主件和附件
// 主件的购买没有限制，钱够就可以；附件的购买有限制，该附件所归属的主件先购买，才能购买这个附件
// 例如，若想买打印机或扫描仪这样的附件，必须先购买电脑这个主件
// 以下是一些主件及其附件的展示：
// 电脑：打印机，扫描仪 | 书柜：图书 | 书桌：台灯，文具 | 工作椅：无附件
// 每个主件最多有2个附件，并且附件不会再有附件，主件购买后，怎么去选择归属附件完全随意，钱够就可以
// 所有的物品编号都在1~m之间，每个物品有三个信息：价格v、重要度p、归属q
// 价格就是花费，价格 * 重要度 就是收益，归属就是该商品是依附于哪个编号的主件
// 比如一件商品信息为[300,2,6]，花费300，收益600，该商品是6号主件商品的附件
// 再比如一件商品信息[100,4,0]，花费100，收益400，该商品自身是主件(q==0)
// 给定m件商品的信息，给定总钱数n，返回在不违反购买规则的情况下最大的收益
// 测试链接 : https://www.luogu.com.cn/problem/P1064

就是把主件和归属于他的附件打包作为一个复合商品
我们做背包是只考虑每个符合商品取与不取，如果取了这个符合商品，展开时也考虑取多少附件，无非就是展开可能性多了。
题目数据也不会为难你，一个主件，最多2个附件，这样展开也不会很难