5最长回文子串 516最长回文子序列

这两道题很像大的，dp数组都是设计为字符串从i到j的子串这样一个二维数组

主要还是由于性质决定的，这种题一般都会跟chari  charj是否相等有关

5    i到j是回文串，可以判断i+1到j-1是回文，并且chari=charj，如果chari不等charj就不是回文串

516  如果chari=charj，那么从i到j的最大回文子序列就是从i+1到j-1的最大值加2.如果不相等，那么则是dp[i+1][j]和dp[i][j-1]的较大值

这两道都是沿着一条一条对角线方向dp。

72编辑距离 712Ascii删除值 115s的子序列出现t的次数
这两个很像，本质都是想把两个字符串调整成一样的，计算调整的代价
dp数组都是把word1的前i个变换成word2的前j个的代价，作为dp[i][j] 
分类讨论还是跟chari与charj是否相等有关
72若相等不用调整直接等于dp[i-1][j-1]，否则是尝试由一步操作加上dp[i-1][j],dp[i][j-1],dp[i-1][j-1]较小
712也是相等最后一个都不用删，否则他们俩选择一个删，两情况选代价最小的

115这道题dp[i][j]也是s的前i个字符子序列中，包含t的前j个字符的数量
不过这道题我们是先想到了转移方程，也就是if(s(i)==t(j))   dp[i][j]=dp[i-1][j]+dp[i-1][j-1]
else dp[i][j]=dp[i-1][j] 很好想的


139单词拆分
这道题他dp复杂度还是n平方，可能真是办法不多了
i从0到n-1，j从0到i，都遍历一下。
找dp[j]==true && set.contains(s.substring(j+1,i+1))
