主要解决找到当前元素左侧第一个比它大(或小)的元素，右侧第一个比它大(或小)的元素。

基本写法：
n是所给数组长度
Deque<Integer> stk=new ArrayDeque<>();
int[] ans=new int[n];
Array.fill(ans,-1);    //初始全赋值成-1是个很常见的操作
for(int i=0;i<n;i++)
{
while(!stk.isEmpty() && arr[stk.peekLast()]<arr[i])  //后面大于号还是小于号要看想要什么
//想要找最近的比它大的就维护单调减少的单调栈，找最近的比他小的就维护单调增加的单调栈
{
	ans[stk.pollLast()]=arr[i];
}
stk.addLast(i);    //这里常见的就是索引入栈，有好处
}

要注意从0遍历到n-1是找右侧第一个比自己大或小的元素
从n-1遍历到0是找左侧第一个比自己大或小的元素



## 遍历方向决定左侧还是右侧，单调栈递增递减决定找下一个更大还是更小.    初始全赋值-1，索引入栈，好处多多